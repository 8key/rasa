---
id: unexpected-input
sidebar_label: Handling Unexpected Input
title: Handling Unexpected Input
---

# WHAT IS THIS PATTERN: handling unexpected but in-scope user input gracefully
# HOW TO IMPLEMENT: 
  ## TOOLS to use
### reverted (is this a thing they should ever actually do)
### rules
### stories
  ## DATA 
### trigger rules
### interruption stories
#### interruption stories for forms dependant on requested slot
#### interruption stories with retrieval intents

One thing you can count on when building a conversational assistant is that users
will say unexpected things. Any deviation from the [`happy paths`](glossary.mdx#happy_unhappy_paths)
that you have defined can be considered unexpected input or interjections. For example:

- A user walks away in the middle of a conversation, then comes back
and says "hi!"
- A user asks "Why do you need to know that?" when the bot asks for information like their email address.

The decision to handle unexpected user input should always come from reviewing
real conversations. You should first build part of your assistant, test it with real users
(whether that's your end user, or your colleague) and then add what's missing. You shouldn't
try to implement every possible edge case that you think might happen, because in the end
your users may never actually behave in that way.
[Rasa X](https://rasa.com/docs/rasa-x/)
is a tool that can help you review conversations and make these types of decisions.

This page is a guide on methods for handling unexpected input. Depending on what kind of unexpected
input you're trying to handle, some or all of the methods describe may be applicable for you.


## Concepts
### `UserUtteranceReverted`

If you have generic interjections that should always have the same single response no
matter the context, you can use the [`RulePolicy`](./policies.mdx#rule-policy) and define 
short rules for the interjecting intents and the responses that should always be returned. 
When combined with a forgetting mechanism, this won't affect your dialogue history either, so
you won't need to write any stories showing the interruption.

For example, let's say you see users having conversations like the following one with
your assistant, where they write a greeting in the middle of a conversation -
maybe because they were gone for a few minutes:

<img alt="Greeting Interjection" src={useBaseUrl("/img/greet_interjection.png")} width="240" />

The greet intent is a good example where we will always give the same response and
yet we don't want the intent to affect the dialogue history. To do this, the response
must be an action that returns the `UserUtteranceReverted()` event to remove the
interaction from the dialogue history.

First, make sure the `RulePolicy` is in the policies section of your configuration file:

```yaml
policies:
  - name: RulePolicy
```

Next, we need to define `action_greet`. Add the following action to your `actions.py` file:

```python
from rasa_sdk import Action
from rasa_sdk.events import UserUtteranceReverted

class ActionGreetUser(Action):
"""Revertible mapped action for utter_greet"""

def name(self):
    return "action_greet"

def run(self, dispatcher, tracker, domain):
    dispatcher.utter_message(template="utter_greet")
    return [UserUtteranceReverted()]
```

This action will return the `utter_greet` response to the user, before removing the interaction from the dialogue history.

You'll need to add `action_greet` and the `greet` intent to your domain:

```yaml
intents: 
  - greet
  # other intents
actions: 
  - action_greet
  # other actions
```


FAQs are another kind of generic interjections that should always get the same response.
For example, a user might ask a related FAQ in the middle of filling a form:

### 


<img alt="Generic Interjections" src={useBaseUrl("/img/generic_interjection.png")} width="240" />

To handle FAQs defined with retrieval actions, you can add a simple story that will be handled by the MemoizationPolicy:

```md
## just sales, continue
* contact_sales
    - sales_form
    - form{"name": "sales_form"}
* faq
    - respond_faq
    - sales_form
    - form{"name": null}
```

This will break out of the form and deal with the users FAQ question, and then return back to the original task.
For example:



<img alt="Generic Interjection Handled" src={useBaseUrl("/img/generic_interjection_handled.png")} width="240" />

If you find it difficult to write stories in this format, you can always use [Interactive Learning](./writing-stories.mdx#interactive-learning)
to help you create them.

As always, make sure to add an end to end test case to your test_stories.md file.

## Contextual questions

You can also handle contextual questions,
like the user asking the question “Why do you need to know that”. The user could ask this based on a certain slot
the bot has requested, and the response should differ for each slot. For example:



<img alt="Contextual Interjection" src={useBaseUrl("/img/contextual_interjection.png")} width="240" />

To handle this, we need to make the `requested_slot` featurized, and assign it the categorical type:

```yaml
slots:
  requested_slot:
    type: categorical
    values:
      - business_email
      - company
      - person_name
      - use_case
      - budget
      - job_function
```

This means that Core will pay attention to the value of the slot when making a prediction
(read more about other [featurized slots](./domain.mdx#slots), whereas
unfeaturized slots are only used for storing information. The stories for this should look as follows:

```md
## explain email
* contact_sales
    - sales_form
    - form{"name": "sales_form"}
    - slot{"requested_slot": "business_email"}
* explain
    - utter_explain_why_email
    - sales_form
    - form{"name": null}

## explain budget
* contact_sales
    - sales_form
    - form{"name": "sales_form"}
    - slot{"requested_slot": "budget"}
* explain
    - utter_explain_why_budget
    - sales_form
    - form{"name": null}
```

We'll need to add the intent and utterances we just added to our `domain.yml` file:

```yaml
intents:
- greet: {triggers: action_greet_user}
- bye
- thank
- faq
- explain

responses:
  utter_explain_why_budget:
  - text: We need to know your budget to recommend a subscription
  utter_explain_why_email:
  - text: We need your email so we can contact you
```

Finally, we'll need to add some NLU data for the explain intent:

```md
## intent:explain
- why
- why is that
- why do you need it
- why do you need to know that?
- could you explain why you need it?
```

Then you can retrain your bot and test it again:

```bash
rasa train
rasa shell
```

:::note
You will need to add a story for each of the values of the `requested_slot` slot
for the bot to handle every case of “Why do you need to know that”

:::

Don't forget to add a few end to end stories to your `test_stories.md` for testing as well.

:::note
Here's a minimal checklist of  of files we modified to handle unexpected user input:

* `actions.py`: Define `action_greet`

* `data/nlu.md`: Add training data for an `explain` intent

* `domain.yml`:

    * Map intent `greet` to  `action_greet_user`

    * Make `requested_slot` a categorical slot with all required slots as values

    * Add the `explain` intent

    * Add responses for contextual question interruptions

* `data/stories.md`:

    * Remove stories using mapped intents if you have them

    * Add stories with FAQ & contextual interruptions in the middle of filling a form

:::
